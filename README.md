# Assignment-3
COP 4520

For problem 1, I attempted to implement a linked list that implements Fine-Grained synchronization. I followed the implementation stated in the course textbook. I followed it closely, 
creating a custom node class to fill the Fine-Grained List. To implement this type of synchronization, since Fine-Grained involves a more specific locking of the part of the list, I 
created custom lock and unlock methods for the node class and these methods were used to lock and unlock the specific parts of the list were being touched, in this case the nodes of the 
list. How the locking is called and how the unlocking is called is implemented as shown in the book where the current node and predecessor are locked and unlocked individually instead 
of the whole list being locked and unlocked. This explanation constitutes my final attempt at answering this question, my first attempt utilized Coarse-Grained synchronization which was 
relatively unsuccessful as it made the runtime way too long. For my final attempt, using Fine-Grained Synchronization, the runtime was under 20 seconds for 5, 50, 500, and 5000 
presents. For 50,000, it reached 180 seconds, and for 500,000 presents it reached more than 10 minutes. For the asked number of presents. The thread implementation of this program, was 
made to run while there are still presents left and until a number of letters were made to match the initial number of presents. In the run and loop, the thread will access a random 
present ID, in this case just an integer, and will generate a random number between 1 and 3 to simulate being handed a random task of the three described in the pdf prompt. The tasks 
are implemented as methods in the list class. In the main class, the threads and list were initialized. and the amounts of presents and letters made were printed before the threads 
start and after the threads finish work. Success was declared once the number presents left and the number of letters were made to match the initial number of presents.
For problem 2, what I did was write up a two priority queues to record the requested top and low 5 temperatures from the "hour" session. Both queue classes included methods to print said queues and also methods to grab the top value in respect to each queue's rules. I used reentrant locks to control access to both queues. The threads run in a for loop to collect the temperature recordings for 60 times to simulate an hour of work. First, the recorded temperature is tested to see if it falls in the high queue, if it does not, then it is moved to test for the low temperature queue, if yes, then the replaced temperature gets tested for the low queue. The other actions pertain to the class tops which is an array class used to get 10-minute interval of time when the largest temperature difference was observed. The actions are grabbing the highest and lowest temp recorded at each minute and test it to see if it makes the array that holds the absolute highest and lowest temperature. The array class tops, is meant to hold and record the absolute highest and lowest temperature recorded at each minute from the several sensors, then the 10-minute interval of time when the largest temperature difference was observed is calculated using this array. The said 10-minute interval and the two queue contents are printed at the end. Runtime for this implementation was 2-3 seconds.
